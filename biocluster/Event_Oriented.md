=========================
事件驱动编程
=========================
查看其它章节：
    * [概述](biocluster)
    * [基础](/biocluster/Basic)
    * [事件驱动编程](/biocluster/Event_Oriented)
    * [Module/Workflow开发](/biocluster/Moudule_Workflow)
    * [Tool/Agent开发](/biocluster/Tool_Agent)
    * [运行和测试](/biocluster/Run_Test)

-----------------------
概念
-----------------------
要理解事件驱动和程序，就需要与非事件驱动的程序进行比较。实际上，现代的程序大多是事件驱动的，比如多线程的程序，肯定是事件驱动的。早期则存在许多非事件驱动的程序，这样的程序，在需要等待某个条件触发时，会不断地检查这个条件，直到条件满足，这是很浪费cpu时间的。而事件驱动的程序，则有机会释放cpu从而进入睡眠态（注意是有机会，当然程序也可自行决定不释放cpu），当事件触发时被操作系统唤醒，这样就能更加有效地使用cpu.

再说什么是事件驱动的程序。一个典型的事件驱动的程序，就是一个死循环，并以一个线程的形式存在，这个死循环包括两个部分，第一个部分是按照一定的条件接收并选择一个要处理的事件，第二个部分就是事件的处理过程。程序的执行过程就是选择事件和处理事件，而当没有任何事件触发时，程序会因查询事件队列失败而进入睡眠状态，从而释放cpu。

事件驱动的程序，必定会直接或者间接拥有一个事件队列，用于存储未能及时处理的事件。

事件驱动的程序的行为，完全受外部输入的事件控制，所以，事件驱动的系统中，存在大量这种程序，并以事件作为主要的通信方式。

事件驱动的程序，还有一个最大的好处，就是可以按照一定的顺序处理队列中的事件，而这个顺序则是由事件的触发顺序决定的，这一特性往往被用于保证某些过程的原子化。

目前windows,linux,nucleus,vxworks都是事件驱动的，只有一些单片机可能是非事件驱动的。

事件驱动的一般步骤：

	1、确定响应事件的元素

	2、为指定元素确定需要响应的事件类型

	3、为指定元素的指定事件编写相应的事件处理程序

	4、将事件处理程序绑定到指定元素的指定事件

-----------------------
多线程和微线程
-----------------------
**线程**:

每个正在系统上运行的程序都是一个进程。每个进程包含一到多个线程。进程也可能是整个程序或者是部分程序的动态执行。线程是一组指令的集合，或者是程序的特殊段，它可以在程序里独立执行。也可以把它理解为代码运行的上下文。所以线程基本上是轻量级的进程，它负责在单个程序里执行多任务。通常由操作系统负责多个线程的调度和执行。

线程是程序中一个单一的顺序控制流程.在单个程序中同时运行多个线程完成不同的工作,称为多线程.

线程和进程的区别在于,子进程和父进程有不同的代码和数据空间,而多个线程则共享数据空间,每个线程有自己的执行堆栈和程序计数器为其执行上下文.多线程主要是为了节约CPU时间,发挥利用,根据具体情况而定. 线程的运行中需要使用计算机的内存资源和CPU。

**优点**

	+ 使用线程可以把占据时间长的程序中的任务放到后台去处理
	+ 用户界面可以更加吸引人，这样比如用户点击了一个按钮去触发某些事件的处理，可以弹出一个进度条来显示处理的进度
	+ 程序的运行速度可能加快
	+ 在一些等待的任务实现上如用户输入、文件读写和网络收发数据等，线程就比较有用了。在这种情况下可以释放一些珍贵的资源如内存占用等等。
	+ 多线程技术在IOS软件开发中也有举足轻重的位置。
	+ 线程应用的好处还有很多，就不一一说明了

**缺点**

	+ 如果有大量的线程,会影响性能,因为操作系统需要在它们之间切换。
	+ 更多的线程需要更多的内存空间。
	+ 线程可能会给程序带来更多“bug”，因此要小心使用。
	+ 线程的中止需要考虑其对程序运行的影响。
	+ 通常块模型数据是在多个线程间共享的，需要防止线程死锁情况的发生。

**微线程**

你可以把它理解为相对于线程更轻量级的逻辑线程，这就好比线程相对于进程来说更轻量级不知道这算不算是纤程的概念。总之微线程都是逻辑上的概念而真实运行的只有一个线程。我们知道在同一时间片只能有一个线程针对一个cpu执行指令，而且其他的线程必须被挂起。然后内核调度程序不断的唤醒/挂起线程来模拟多个任务的执行，而如果对线程使用不当就会造成过多的线程切换开销。而实际上很多线程切换是没有必要的，因为真正工作的线程在同一时间只有一个因此我们可以写一个很简单的调度来实现微线程之间的切换。这同时还带了一个很大的好处就是微线程中的代码永远是线程安全的因为不会出现竞争条件了。但这同时引入了一个问题就是微线程中怎么实现挂起/激活操作，因为我们不可能在微线程中使用Sleep这种阻塞调用这会让所有的微线程全部阻塞。在现有的语言基础上解决这个问题的最简单办法就是使用协程，或者说使用迭代器模式，yield关键字。微线程中如果需要阻塞的时候就yield return 把把具体工作交给外部协作协程来处理，等处理完了再回到微线程中继续执行yield return后面的代码。这个过程在概念上与实际的线程挂起/唤醒是相同的，并且切换代价要小的多。

-----------------------
同步和异步执行
-----------------------
**同步**

	所谓同步，就是在发出一个功能调用时，在没有得到结果之前，该调用就不返回。

**异步**

	异步的概念和同步相对。当一个异步过程调用发出后，调用者不会立刻得到结果。实际处理这个调用的部件是在调用发出后，通过状态、通知来通知调用者，或通过回调函数处理这个调用。


[img](img/flow.gif)

   02 异步运行

-----------------------
阻塞与非阻塞
-----------------------

**阻塞**

	阻塞调用是指调用结果返回之前，当前线程会被挂起。函数只有在得到结果之后才会返回。

**非阻塞**

	非阻塞和阻塞的概念相对应，指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。

-----------------------
事件对象
-----------------------

下文中我们称事件对象为EventObject.

在Biocluster框架中，EventObject由biocluster.core.event.EventObject派生出来，所有事件对象都是biocluster.core.event.EventObject的子类实例。每个EventObject可以为其定义多个类型的事件处理器(biocluster.core.event.EventHandler)。

EventHandler需要为其添加一个或多个事件处理函数,事件未触发时，这些函数处于待运行状态，到事件触发时，这些函数会立即执行。

Biocluster框架中每个处理函数即为一个微线程，所以不应该在EventObject使用任何阻塞函数。

包含如下类基础了EventObject:
Basic
Workflow
Module
Agent

使用事件的流程如下：

	* EventObject可作为确定响应事件的元素

	* 需要为EventObject添加需要响应的EventHandler

	* 为EventObject EventHandler编写相应的事件处理程序

	* 将事件处理程序绑定到指定元素的指定事件

实例代码:

```



		from biocluster.core.event import EventObject


		class ExtendEventObject(EventObject):

			def __init__(self):
				super(ExtendEventObject, self).__init__()
				self.test1 = "I'm testfunc1"
				self.test2 = "I'm testfunc2"
				self.add_event("test1")         # 添加事件test1
				self.on("test1", self.testfunc1)  # 绑定事件方法
				self.add_event("test2")   # 添加事件test2
				self.on("test2", self.testfunc2)  # 绑定事件方法

			def testfunc1(self):
				print self.test1

			def testfunc2(self, x):
				print "%s and %s" % (self.test2, x)


		def testfunc3(eventobj):
			print "wait function will exit"
			eventobj.set_end()   # 设置EventObject为完成状态，wait()函数即停止阻塞主线程

		testobj = ExtendEventObject()  # 实例化类
		testobj.add_event("test3")    # 添加事件test3
		testobj.on("test3", testfunc3)  # 绑定事件方法
		testobj.start_listener()  # 启动事件监听
		testobj.fire("test1")   # 触发事件test1
		testobj.fire("test2", "I'm x")   # 触发事件test2
		testobj.fire("test3", testobj)   # 触发事件test3,并传递testobj对象
		testobj.wait()  # 阻塞主线程等待时间执行结束

		查看其它章节：
		    * [概述](biocluster)
		    * [基础](/biocluster/Basic)
		    * [事件驱动编程](/biocluster/Event_Oriented)
		    * [Module/Workflow开发](/biocluster/Moudule_Workflow)
		    * [Tool/Agent开发](/biocluster/Tool_Agent)
		    * [运行和测试](/biocluster/Run_Test)
```
